import { FileTree, Tabs } from "nextra/components";
import { Note, Tip } from "@/components/Advice";

# Test Runner

The heart TSTyche is the test runner. This page walks through its most important features.

<Note>

This page assumes you already know how to install TSTyche and run type tests. If not, head to the [Introduction](./introduction.mdx) first.

</Note>

## TypeScript Versions

The TSTyche test runner does not execute the code. Instead it passes the code through TypeScript's type checker and reports back with the result. In a way you can see TSTyche as a type checker with benefits.

By default, the currently installed `typescript` package is used. To specify other version of TypeScript to test on, pass the [`--target`](../reference/command-line.mdx#target) command line option (or use the [`target`](../reference/config-file.mdx#target) configuration option):

<Tabs items={["npm", "yarn", "pnpm"]} storageKey={"preferredPackageManager"}>
<Tabs.Tab>

```shell
npx tstyche --target 4.8,current
```

</Tabs.Tab>
<Tabs.Tab>

```shell
yarn tstyche --target 4.8,current
```

</Tabs.Tab>
<Tabs.Tab>

```shell
pnpm tstyche --target 4.8,current
```

</Tabs.Tab>
</Tabs>

If you run this command using the example from the [Introduction](./introduction.mdx), the report should include two versions of TypeScript:

```ansi
[90madds[0m TypeScript 4.8.4[90m to /Users/CandyCat/Library/TSTyche/4.8.4[0m
[34muses[0m TypeScript 4.8.4[90m with ./tsconfig.json[0m

[32mpass[0m [90m./[0mMethodLikeKeys.tst.ts

[34muses[0m TypeScript 5.5.2[90m with ./tsconfig.json[0m

[32mpass[0m [90m./[0mMethodLikeKeys.tst.ts
```

<Tip>

At this point you can rest assured that typings can be used with TypeScript 4.8 and the currently installed version. Wondering about the future? Specify `beta`, `latest`, `next` or `rc` as the target tag.

</Tip>

## The Store

First line of the above report tells that the requested version of TypeScript was added to the store. The TSTyche store is a tiny package manager which downloads the requested versions of `typescript` package. The packages are kept in the global cache, this means running TSTyche in any project will reuse already installed packages.

To know how to resolve tags like `latest` or `next`, every two hours the store fetches the `typescript` package metadata.

These are the command line options dedicated to the store:

- [`--install`](../reference/command-line.mdx#install) adds the specified versions of TypeScript, useful if you are preparing to work offline,
- [`--prune`](../reference/command-line.mdx#prune) removes the whole cache directory, if you want to free up disk space or to resolve a store issue,
- [`--update`](../reference/command-line.mdx#update) force updates the `typescript` package metadata from the registry.

## Functional Tests

Any file which can be type checked can also be a type test. For instance, TSTyche assertions can be mixed into a usage examples or a functional tests:

```ts filename="./src/secondItem.ts"
export function secondItem<T>(target: Array<T>): T | undefined {
  return target[1];
}
```

```ts filename="./src/__tests__/secondItem.test.ts"
import assert from "node:assert";
import test from "node:test";
import * as tstyche from "tstyche";
import { secondItem } from "../secondItem.js";

test("handles numbers", () => {
  assert.strictEqual(secondItem([1, 2, 3]), 2);

  tstyche.expect(secondItem([1, 2, 3])).type.toBe<number | undefined>();
  });
});
```

Use the [`testFileMatch`](../reference/config-file.mdx#test-file-match) configuration option to include files in the test run:

```json filename="./tstyche.config.json"
{
  "testFileMatch": ["**/*.test.ts", "**/*.tst.ts"]
}
```

<Note>

TSTyche assertions and testing helpers are just empty functions returning `undefined`. They do nothing when invoked by a JavaScript test runner.

</Note>

## Selecting Test Files

Passing one or more search strings to the `tstyche` command runs only the test files with matching paths. For example, if a project structure look like this:

<FileTree>
  <FileTree.Folder name="src" defaultOpen>
    <FileTree.Folder name="__tests__" defaultOpen>
      <FileTree.File name="lastItem.test.ts" />
      <FileTree.File name="secondItem.test.ts" />
    </FileTree.Folder>
    <FileTree.File name="lastItem.ts" />
    <FileTree.File name="secondItem.ts" />
  </FileTree.Folder>
</FileTree>

The following will select only the `secondItem.test.ts` file:

<Tabs items={["npm", "yarn", "pnpm"]} storageKey={"preferredPackageManager"}>
<Tabs.Tab>

```shell
npx tstyche second
```

</Tabs.Tab>
<Tabs.Tab>

```shell
yarn tstyche second
```

</Tabs.Tab>
<Tabs.Tab>

```shell
pnpm tstyche second
```

</Tabs.Tab>
</Tabs>

## Filtering Tests

To organize a larger test file, TSTyche's [`describe()`](../reference/testing-api.mdx#describe) and [`test()`](../reference/testing-api.mdx#test) helpers can be used:

```ts
import { describe, expect, test } from "tstyche";
import type * as tstyche from "tstyche/tstyche";

const options: tstyche.ConfigFileOptions = {};

describe("ConfigFileOptions", () => {
  test("'failFast' option", () => {
    expect<Pick<tstyche.ConfigFileOptions, "failFast">>().type.toBe<{
      failFast?: boolean;
    }>();
  });

  test("'target' option", () => {
    expect<Pick<tstyche.ConfigFileOptions, "target">>().type.toBe<{
      target?: Array<string>;
    }>();
  });
});
```

This is a fragment of TSTyche's `ConfigFileOptions` interface test. The type is generated by a script and this test makes sure that the resulting code is correct.

While developing similar script, the [run mode flags](../reference/testing-api.mdx#run-mode-flags) come in handy. Use `.only` to focus on or `.skip` to skip some of the tests:

```ts
describe.only("ConfigFileOptions", () => {
  test.skip("'failFast' option", () => {
    // ...
  });

  test("'target' option", () => {
    // ...
  });
});
```

Tests can be selected by their name straight from the command line through the [`--only`](../reference/command-line.mdx#only) and [`--skip`](../reference/command-line.mdx#skip) filters:

<Tabs items={["npm", "yarn", "pnpm"]} storageKey={"preferredPackageManager"}>
<Tabs.Tab>

```shell
npx tstyche --only configFile --skip failFast
```

</Tabs.Tab>
<Tabs.Tab>

```shell
yarn tstyche --only configFile --skip failFast
```

</Tabs.Tab>
<Tabs.Tab>

```shell
pnpm tstyche --only configFile --skip failFast
```

</Tabs.Tab>
</Tabs>

## Filtering Assertions

TSTyche assertions support the [run mode flags](../reference/expect-api.mdx#run-mode-flags) too. Besides focusing and skipping you can also mark them as failing. A supposed to fail assertion raises an error only if it passes.

```ts
import { expect } from "tstyche";
import type * as tstyche from "tstyche/tstyche";

expect.skip<tstyche.ConfigFileOptions>().type.toMatch<{
  failFast?: boolean;
}>();

expect.fail<tstyche.ConfigFileOptions>().type.toMatch<{
  target?: string;
}>();
```

## Expecting Errors

Speaking of assertions and errors, TSTyche has a special [`.toRaiseError()`](../reference/expect-api.mdx#to-raise-error) matcher. It checks if the provided type or expression raises a particular TypeScript error:

```ts
import { expect } from "tstyche";

function firstItem<T>(target: Array<T>): T | undefined {
  return target[0];
}

expect(firstItem()).type.toRaiseError("Expected 1 argument");
```
