import { FileTree } from "nextra/components";
import { Note, Tip } from "@/components/Advice";

# Walkthrough

This page offers a quick overview of the most important features of TSTyche.

## How It Works?

The TSTyche test runner does not execute the code. Instead, it passes the code through TypeScript’s type checker and reports back with the result. In a way, you can see TSTyche as a type checker with benefits.

To learn more, see the [Introduction](./introduction.mdx) page.

## Testing Specific Version of TypeScript

TSTyche has everything you need to test against a specific version of TypeScript:

```shell
tstyche --target 5.4
```

The above command runs tests using TypeScript `5.4.5`. You can specify a range of versions as well:

```shell
tstyche --target '>=5.6'
```

To learn more, see the [TypeScript Versions](../guides/typescript-versions.mdx) page.

## Integrating into Unit Tests

The assertions can be mixed into unit tests as well:

```ts filename="./src/toMilliseconds.ts"
function toMilliseconds(value: number) {
  if (typeof value === "number" && !Number.isNaN(value)) {
    return value * 1000;
  }

  throw new Error("Not a number");
}
```

```ts filename="./src/__tests__/toMilliseconds.test.ts"
import assert from "node:assert";
import test from "node:test";
import * as tstyche from "tstyche";
import { toMilliseconds } from "../toMilliseconds.js";

test("toMilliseconds", () => {
  const sample = toMilliseconds(10);

  assert.equal(sample, 10_000);
  tstyche.expect(sample).type.toBe<number>();

  // Will pass as a type test and not throw at runtime
  tstyche.expect(toMilliseconds).type.not.toBeCallableWith("20");
});
```

Use the [`testFileMatch`](../reference/config-file.mdx#test-file-match) configuration option to include files in the test run:

```json filename="./tstyche.config.json"
{
  "testFileMatch": ["**/*.test.ts", "**/*.tst.ts"]
}
```

<Note>

TSTyche assertions and testing helpers are just empty functions returning `undefined`. They do nothing when invoked by a JavaScript test runner.

</Note>

## Selecting Test Files

Passing one or more search strings to the `tstyche` command runs only the test files with matching paths. For example, if a project structure look like this:

<FileTree>
  <FileTree.Folder name="src" defaultOpen>
    <FileTree.Folder name="__tests__" defaultOpen>
      <FileTree.File name="lastItem.test.ts" />
      <FileTree.File name="secondItem.test.ts" />
    </FileTree.Folder>
    <FileTree.File name="lastItem.ts" />
    <FileTree.File name="secondItem.ts" />
  </FileTree.Folder>
</FileTree>

The following will select only the `secondItem.test.ts` file:

```shell
tstyche second
```

## Filtering Tests

To organize a larger test file, the [`describe()`](../reference/testing-api.mdx#describe) and [`test()`](../reference/testing-api.mdx#test) helpers can be used:

```ts
import { describe, expect, test } from "tstyche";
import type * as tstyche from "tstyche/tstyche";

test("all options are optional", () => {
  expect<tstyche.ConfigFileOptions>().type.toBeAssignableWith({});
});

describe("ConfigFileOptions", () => {
  test("'failFast' option", () => {
    expect<Pick<tstyche.ConfigFileOptions, "failFast">>().type.toBe<{
      failFast?: boolean;
    }>();
  });

  test("'target' option", () => {
    expect<Pick<tstyche.ConfigFileOptions, "target">>().type.toBe<{
      target?: Array<string>;
    }>();
  });
});
```

This is a fragment of TSTyche’s `ConfigFileOptions` interface test. The type is generated by a script and this test makes sure that the resulting code is correct.

While developing similar script, the [run mode flags](../reference/testing-api.mdx#run-mode-flags) come in handy. Use `.only` to focus on or `.skip` to skip some of the tests:

```ts
describe.only("ConfigFileOptions", () => {
  test.skip("'failFast' option", () => {
    // ...
  });

  test("'target' option", () => {
    // ...
  });
});
```

Tests can be selected by their name straight from the command line through the [`--only`](../reference/command-line.mdx#only) and [`--skip`](../reference/command-line.mdx#skip) filters:

```shell
tstyche --only configFile --skip failFast
```

## Filtering Assertions

TSTyche assertions support the [run mode flags](../reference/expect-api.mdx#run-mode-flags) too. Besides focusing and skipping you can also mark them as failing. A supposed to fail assertion raises an error only if it passes.

```ts
import { expect } from "tstyche";
import type * as tstyche from "tstyche/tstyche";

expect.skip<Pick<tstyche.ConfigFileOptions, "failFast">>().type.toBe<{
  failFast?: boolean;
}>();
expect.fail<Pick<tstyche.ConfigFileOptions, "target">>().type.toBe<{
  target?: Array<string>;
}>();
```

## Expecting Errors

Speaking of assertions and errors, TSTyche has a special [`.toRaiseError()`](../reference/expect-api.mdx#to-raise-error) matcher. It checks if the provided type or expression raises a particular TypeScript error:

```ts
import { expect } from "tstyche";

function firstItem<T>(target: Array<T>): T | undefined {
  return target[0];
}

expect(firstItem()).type.toRaiseError("Expected 1 argument");
```
