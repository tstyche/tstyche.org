import { FileTree } from "nextra/components";
import { Note, Tip } from "@/components/Advice";

# Walkthrough

An overview of the most important aspects of TSTyche.

## How It Works?

The TSTyche test runner does not execute the code. Instead, it passes the code through TypeScript’s type checker and reports back with the result. In a way, you can see TSTyche as a type checker with benefits.

To learn more, see the [Introduction](./introduction.mdx) page.

## Testing Specific Version of TypeScript

TSTyche has everything you need to test against a specific version of TypeScript:

```shell
tstyche --target 5.4
```

The above command runs tests using TypeScript `5.4.5`. You can specify a range of versions as well:

```shell
tstyche --target '>=5.6'
```

To learn more, see the [TypeScript Versions](../guides/typescript-versions.mdx) page.

## Expecting Errors

The downside of `// @ts-expect-error` is that it hides any errors found in the line following the comment. To address that, TSTyche requires a fragment of the error message after `// @ts-expect-error` and checks if it matches the actual error:

```ts twoslash
// @ts-expect-error Cannot find name 'add'
console.log(add);
```

To learn more, see the documentation of the [`checkSuppressedErrors`](../reference/config-file.mdx#check-suppressed-errors) option.

<Tip>

To indicate the purpose of a test, use matchers like [`.toBeCallableWith()`](../reference/expect-api.mdx#to-be-callable-with) or [`.toHaveProperty()`](../reference/expect-api.mdx#to-have-property) instead of `// @ts-expect-error`.

</Tip>

## Integrating into Unit Tests

The assertions can be mixed into unit tests as well:

```ts twoslash filename="./src/toMilliseconds.ts"
export function toMilliseconds(value: number) {
  if (typeof value === "number" && !Number.isNaN(value)) {
    return value * 1000;
  }

  throw new Error("Not a number");
}
```

```ts twoslash filename="./src/__tests__/toMilliseconds.test.ts"
// @filename: ./src/toMilliseconds.ts
export function toMilliseconds(value: number) {
  if (typeof value === "number" && !Number.isNaN(value)) {
    return value * 1000;
  }

  throw new Error("Not a number");
}
// @filename: ./src/__tests__/toMilliseconds.test.ts
// ---cut---
import assert from "node:assert";
import test from "node:test";
import * as tstyche from "tstyche";
import { toMilliseconds } from "../toMilliseconds.js";

test("toMilliseconds", () => {
  const sample = toMilliseconds(10);

  assert.equal(sample, 10_000);
  tstyche.expect(sample).type.toBe<number>();

  // Will pass as a type test and not throw at runtime
  tstyche.expect(toMilliseconds).type.not.toBeCallableWith("20");
});
```

Use the [`testFileMatch`](../reference/config-file.mdx#test-file-match) configuration option to include files in the test run:

```json filename="./tstyche.config.json"
{
  "testFileMatch": ["**/*.test.ts", "**/*.tst.ts"]
}
```

<Note>

TSTyche assertions and testing helpers are just empty functions returning `undefined`. They do nothing when invoked by a JavaScript test runner.

</Note>

## Selecting Test Files

Passing one or more search strings to the `tstyche` command runs only the test files with matching paths. For example, if a project structure look like this:

<FileTree>
  <FileTree.Folder name="src" open>
    <FileTree.Folder name="__tests__" open>
      <FileTree.File name="lastItem.test.ts" />
      <FileTree.File name="secondItem.test.ts" active />
    </FileTree.Folder>
    <FileTree.File name="lastItem.ts" />
    <FileTree.File name="secondItem.ts" />
  </FileTree.Folder>
</FileTree>

The following will select only the `secondItem.test.ts` file:

```shell
tstyche second
```

## Filtering Tests

To organize a larger test file, the [`describe()`](../reference/testing-api.mdx#describe) and [`test()`](../reference/testing-api.mdx#test) helpers can be used:

```ts twoslash
import { describe, expect, test } from "tstyche";
// ---cut-start---
interface ConfigFileOptions { failFast?: boolean; target?: Array<string> }
// ---cut-end---

test("all options are optional", () => {
  expect<ConfigFileOptions>().type.toBeAssignableWith({});
});

describe("ConfigFileOptions", () => {
  test("'failFast' option", () => {
    expect<Pick<ConfigFileOptions, "failFast">>().type.toBe<{
      failFast?: boolean;
    }>();
  });

  test("'target' option", () => {
    expect<Pick<ConfigFileOptions, "target">>().type.toBe<{
      target?: Array<string>;
    }>();
  });
});
```

This is a fragment of TSTyche’s `ConfigFileOptions` interface test. The type is generated by a script and this test makes sure that the resulting code is correct.

While developing similar script, the [run mode flags](../reference/testing-api.mdx#run-mode-flags) come in handy. Use `.only` to focus on or `.skip` to skip some of the tests:

```ts twoslash
import { describe, expect, test } from "tstyche";
// ---cut---
describe.only("ConfigFileOptions", () => {
  test.skip("'failFast' option", () => {
    // ...
  });

  test("'target' option", () => {
    // ...
  });
});
```

Tests can be selected by their name straight from the command line through the [`--only`](../reference/command-line.mdx#only) and [`--skip`](../reference/command-line.mdx#skip) filters:

```shell
tstyche --only configFile --skip failFast
```

## Filtering Assertions

TSTyche assertions support the [run mode flags](../reference/expect-api.mdx#run-mode-flags) too. Besides focusing and skipping you can also mark them as failing. A supposed to fail assertion raises an error only if it passes.

```ts
import { expect } from "tstyche";
import type * as tstyche from "tstyche/tstyche";

expect.skip<Pick<tstyche.ConfigFileOptions, "failFast">>().type.toBe<{
  failFast?: boolean;
}>();
expect.fail<Pick<tstyche.ConfigFileOptions, "target">>().type.toBe<{
  target?: Array<string>;
}>();
```
